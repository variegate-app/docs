package sort

/*
QuickSort

Временная сложность: в среднем O(n log n) , в худшем случае O(n^2) (если выбор опорного элемента неудачен)
Пространственная сложность: O(log n) из-за рекурсии.

Преимущество: Очень быстрый для больших массивов.
Недостаток: В худшем случае может иметь плохую производительность.

Принцип работы: Выбирается опорный элемент (pivot), массив разделяется на две части: элементы, меньшие чем pivot, и элементы, большие чем pivot. Затем рекурсивно сортируются обе части.

Шаги:
- Выбираем опорный элемент (например, последний элемент массива).
- Разбиваем массив на две части: элементы меньше опорного и элементы больше опорного.
- Рекурсивно сортируем обе части.
*/
func QuickSort(numbers []int) []int {
	if len(numbers) < 2 {
		return numbers
	}

	pivot := numbers[len(numbers)/2]
	left := []int{}
	right := []int{}

	for _, num := range numbers {
		if num < pivot {
			left = append(left, num)
		} else if num > pivot {
			right = append(right, num)
		}
	}

	// Учитываем равные pivot элементы
	return append(append(QuickSort(left), pivot), QuickSort(right)...)
}
