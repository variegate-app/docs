package sort

/*
MergeSort

Временная сложность: O(n log n) во всех случаях.
Пространственная сложность: O(n), так как требуется дополнительная память для хранения объединенных массивов.

Преимущество: Отличная производительность при больших объемах данных.
Недостаток: Использует дополнительную память.

Принцип работы: Массив рекурсивно делится на две части, каждая из которых сортируется, а затем сливаются в один отсортированный массив.
Шаги:
- Разбиваем массив на две половины.
- Рекурсивно сортируем обе половины.
- Сливаем отсортированные половины в один отсортированный массив.
*/
func MergeSort(numbers []int) []int {
	if len(numbers) < 2 {
		return numbers
	}

	mid := len(numbers) / 2
	left := MergeSort(numbers[:mid])
	right := MergeSort(numbers[mid:])

	return merge(left, right)
}

// Функция для слияния двух упорядоченных подмассивов
func merge(a, b []int) []int {
	c := make([]int, len(a)+len(b))
	i, j := 0, 0
	for i < len(a) && j < len(b) {
		if a[i] < b[j] {
			c[i+j] = a[i]
			i++
		} else {
			c[i+j] = b[j]
			j++
		}
	}
	if i < len(a) {
		copy(c[i+j:], a[i:])
	} else {
		copy(c[i+j:], b[j:])
	}
	return c
}
