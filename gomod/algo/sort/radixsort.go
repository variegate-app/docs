package sort

import "math"

/*
Временная сложность: O(nk) во всех случаях, где k - количество цифр в наибольшем числе.
Пространственная сложность: O(n + k).

Применение:
- Обработка больших объемов данных:
	Radix Sort особенно эффективен для сортировки больших массивов данных,
	так как его временная сложность составляет O(n * k), где n - количество элементов, а k - количество цифр в наибольшем числе.
	Это делает его более быстрым по сравнению с традиционными алгоритмами сортировки, такими как быстрая сортировка или сортировка слиянием,
	в случае больших наборов данных.
- Стабильность сортировки:
	Radix Sort является стабильным алгоритмом сортировки, что означает, что элементы с одинаковыми значениями сохраняют свой относительный порядок в отсортированном массиве.
	Это важно в некоторых приложениях, где требуется сохранение исходного порядка для одинаковых ключей.
- Параллельная обработка:
	Radix Sort легко поддается распараллеливанию,
	что позволяет эффективно использовать многопоточные и распределенные вычислительные среды для ускорения процесса сортировки.

Минусы: Radix Sort неэффективен для сортировки чисел с плавающей запятой или других типов данных,
которые не могут быть легко сопоставлены с небольшим количеством цифр.
Также он требует значительного объема памяти для подсчета количества появлений каждого цифрового значения,
что может быть проблемой при работе с небольшими наборами данных или данными с небольшим количеством уникальных ключей.
*/

// Функция для сортировки массива с использованием LSD Radix Sort
func RadixSortLSD(arr []int) []int {
	// Максимальная длина числа в массиве
	max := arr[0]
	for _, num := range arr {
		if num > max {
			max = num
		}
	}

	// Количество цифр в максимальном числе
	digits := int(math.Log10(float64(max))) + 1

	// Инициализация вспомогательного массива для подсчета
	count := make([]int, 10)

	// Инициализация выходного массива
	output := make([]int, len(arr))

	// Проход по каждой цифре (справа налево)
	for i := 1; i <= digits; i++ {
		// Инициализация count для текущей цифры
		for j := 0; j < len(arr); j++ {
			digit := (arr[j] / int(math.Pow10(i-1))) % 10
			count[digit]++
		}

		// Обновление count для учета позиции в выходном массиве
		for j := 1; j < 10; j++ {
			count[j] += count[j-1]
		}

		// Копирование элементов в выходной массив в правильном порядке
		for j := len(arr) - 1; j >= 0; j-- {
			digit := (arr[j] / int(math.Pow10(i-1))) % 10
			output[count[digit]-1] = arr[j]
			count[digit]--
		}

		// Копирование отсортированного выходного массива обратно в исходный
		for j := 0; j < len(arr); j++ {
			arr[j] = output[j]
		}
	}

	return arr
}
